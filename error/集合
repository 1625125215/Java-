【一】、非法字符：“\ufeff”解决办法
新引入项目的运行时提示"非法字符：“\ufeff” "，项目报错不能运行
出现原因：编码风格不一致
解决方案：
编码改为GBK格式，再转为UTF-8格式,重新启动项目问题解决；
操作步骤：
在IDEA右下角找到UTF-8字样的编码格式设计项，点击选择第一项GBK，然后Convert，等待项目覆盖结束；



【二】、java: 需要class, interface或enumIDEA解决方法
IDEA如果出现Error:(1, 10) java: 需要class, interface或enum
然后再选择GBK
再换回UTF-8
就行了

【三】、alt+insert在mac上的替代办法（构造）
command+n

【四】、Error:(16, 2) java: 解析时已到达文件结尾
解决方法：
       查看大括号是否匹配正确。

【五】、原因: java.lang.ClassNotFoundException
出现此类时，先考虑编码问题，其次尽量使用英语

【】Java 方法中加void和不加void的 区别
只要记住void即无返回值就OK了，如果不用void，那么这个地方一定是被一个其它的数据类型所替代，比如下面用的是String，当然也可能是int或者Boolean等等，那么此时我们下面就要有一个return返回值。
package com.Thursday.one;
public class Variable {
	public static void speaker(){
		System.out.println("你好");
	}
	public static String Talk(){
		return "hello";
	}
	public static void main(String[] args) {
		speaker();
		Talk();
		String aString = Talk();
		System.out.println(aString);
	}
}

【】intellij新建类
先建立一个Java class，然后打上去interface xxx（此处是类名），自动图标文件转为i


【】getter and setter作用
getter、setter是个很好的中间层。
这两个方法可以方便增加额外功能（比如验证）。
内部存储和外部表现不同。
可以保持外部接口不变的情况下，修改内部存储方式和逻辑。
任意管理变量的生命周期和内存存储方式。
提供一个debug接口。
能够和模拟对象、序列化乃至WPF库等融合。
允许继承者改变语义。
可以将getter、setter用于lambda表达式。（大概即作为一个函数，参与函数传递和运算）
getter和setter可以有不同的访问级别。
封装数据，对私有属性进行封装，只是暴露出public方法来访问。
但是为什么要这么做，原因很简单，封装的作用就是保护，保护属性本身不被篡改。
比如有些属性只是可读但不可写，那么只提供它的getter方法就好，意思就是某些属性只能单一方向的被访问，
getter和setter就是提供这样的接口，对于public的属性，可以直接使用类名来访问，自身的“安全性”就降低了。
 

setter方法
1.可以限制和检验setter方法传入的参数
2.隐藏对象内部数据结构
3.保持对象在每个状态的完整性
getter方法
1.按照客户的期望返回格式化数据
2.控制服务的顺序(例如只有当连接建立时getter方法才返回相应实例)
参考：http://stackoverflow.com/questions/7207994/java-setter-and-getter
框架中写的大部分getter和setter方法都是直接返回和赋值，不过实际上可以在方法中加入访问权限控制、逻辑判断等，实现OO编程中封装和信息隐藏。

其实说得明白点吧，这只是java类（特别的很多时候是一个javabean）的两个方法，以提供对某个变量（字段）设置与访问的两个入口，在很多时候也正如你说，跟定义成public是没有两样的，具体的原因在于：
（1）由于很多框架都是调用这两个方法来实现沟通，这是一种习惯了。
（2）get/set方法也不一定只是简单的作一个赋值，或一个返回值吧，在这里可以作一些权限的控制，比如不是每个角色都可以赋值的。再比如返回的值不一定是值本身，可以是经过处理了的，比如加密，这用public定义是不能作到的。
 



